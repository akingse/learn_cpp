[变量](https://blog.csdn.net/qq_38880380/article/details/80035710)

一、作用域

1、作用域问题：在一个函数中定义的变量，在其他函数中能否被引用？在不同位置定义的变量，在什么范围内有效？

2、定义变量可能有3种情况 [谭浩强]

（1）在函数的开头定义；

（2）在函数内的复合语句内定义；

（3）在函数的外部定义。

3、局部变量

（1）在函数内部定义的变量，只有在本函数内才能引用它们，也只有在本函数范围内有效；

（2）在复合语句内定义的变量，只有在本复合语句内才能引用它们，也只有在本复合语句范围内有效；

（3）举例如下，两个函数中的tmp只作用域在自己的函数体内。

```
//
#include <stdio.h>
 
void cpri()
{
	char tmp= '6';
	printf("cpri: %c\n", tmp);
}
 
void ipri()
{
	int tmp = 666;
	printf("ipri: %d\n", tmp);
}
 
int main()
{
	cpri();
	ipri();
	return 0;
}
//
```

4、全局变量

（1）在函数之外定义的变量是全局变量。

（2）C程序设计中，一般习惯将全局变量名的首字母大写。

（3）尽力减少使用全局变量的原因

a、内存开销大，全局变量在程序整个执行过程中都占有存储单元；

b、降低函数的通用性，不利于函数作为一个功能模块拷贝到别的文件中复用；

c、代码的可阅读性降低，人们难以清楚的判断出每个瞬时，各个外部变量的值。

 

二、变量的存储方式和生命周期

1、变量的存储方式有两种

（1）静态存储方式

   A、静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式。

   B、全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。整个执行过程中它们占据着固定的存储单元。

（2）动态存储方式

   A、动态存储方式是指在程序运行的期间根据需求进行动态的分配存储空间的方式。

   B、动态存储区中存放以下数据：

   ① 函数形式参数。在调用函数时给形参分配存储空间。

   ② 函数中定义的没有用关键字static声明的变量。即自动变量。

   ③ 函数调用时的现场保护和返回地址等。

  注意：上述的分配和释放时动态的，如果一个程序中两次调用同一函数，而在此函数种定义了局部变量，在2次调用时分配该局部变量获得的存储空间的地址可能是不同的。

2、变量的存储类别

（1）C语言中，每一个变量和函数都有2个属性：数据类型和数据的存储类别。C的存储类别有4种：自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）。变量的存储类别对应变量的作用域与生命周期。

3、局部变量的存储类别

（1）自动变量（auto变量）

函数中的局部变量，如果不专门声明是static存储类别，都是动态地分配存储空间的。函数中的形参和在函数中定义的局部变量（包括符合语句中的局部变量）都属于此类。如 函数中定义变量 int a; 和 auto int a; 是等价的，关键字“auto”是默认省略的。

（2）静态局部变量（static局部变量）

有时希望函数中的局部变量的值在函数调用结束后不消失，继续保留原值，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值。此时应该用static声明该变量为“静态局部变量”。

说明：

   A、静态局部变量属于静态存储类别，在静态存储区内分配存储单元。自动变量（即动态局部变量）属于动态存储类别，分配在动态存储空间中。

   B、静态局部变量实在编译时赋初始值的，即只赋值一次。

   C、如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符‘\0’（对字符变量）。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已经释放，下次调用时又重新另分配存储单元，所分配的单元中的内容时不可知的。

   D、虽然静态局部变量在函数调用结束后仍然存在，但别的函数不能引用它。因为它是局部变量。

（3）寄存器变量（register变量）

   A、如果一个变量频繁使用，可以声明为寄存器变量。由于寄存器的读写速度远快于内存的读写速度。所以能提高执行效率。

   B、由于现在的计算机的速度愈来愈快，性能愈来愈高，优化的编译系统能够识别出使用频繁的变量，从而自动地将这些变量放在寄存器中，而不需要程序设计者指定。因此，现在实际上用register声明变量的必要性不大。

4、全局变量的存储类别

    全局变量都是存放在静态存储区中的。

（1）在一个文件内扩展外部变量的作用域，应在引用前用关键字extern对该变量作“外部变量声明”，表示把该外部变量的作用域扩展到此位置。

```
//
#include <stdio.h>
 
int test()
{
    extern num;
    printf("The num is : %d\n", num);
    return 0;
}
 
int num = 666;
 
int main()
{ 
    test();
    return 0;
}
//运行的结果时  The num is : 666
```

注意：用extern声明外部变量时，类型名可写可不写，如"extern int num;"也可以写成"extern num;"。因为它不是定义变量，可以不指定类型，只许写出外部变量名即可。

（2）将外部变量的作用域扩展到其他文件

   A、如在file1.c中定义 int num; 在file2.c中 加上#include "file1.c" ，然后在需要引用的地方前面加上 extern int num; 即可。

注：extern即可以用来扩展外部变量在本文件中的作用域，又可以使外部变量的作用域从一个文件扩展到程序中的其他文件。编译器区别处理原则是：遇到extern时，现在本文件中找外部变量的定义，如果找到，就在本文件中扩展作用域；如果找不到，就在连接时从其他文件中找外部变量的定义。如果找到就将作用域扩展到本文件；如果没有就报错。

（3）将外部变量的作用域限制在本文件中

   A、有时在程序设计中希望某些外部变量只限制被本文件引用，而不被其他文件引用，这时可以在定义外部变量时加一个static声明。

   B、加上 static 声明、只能用于本文件的外部变量称为静态外部变量。

 

注

1、for中初始化语句定义变量

```
#include <stdio.h>
 
int main()
{
	for (int i = 0; i < 3; i++) {
		printf("Hello\n");
	}
	/* printf("%p\n", &i); */
	for (int i = 0; i < 3; i++) {
		printf("World\n");
	}
	return 0;
}
```

代码中两和for 循环初始化语句定义的变量一样，运行没有问题，新版本语法规范规定，for循环中，局部变量内存的分配在循环开始时，释放在循环结束时。

 

---

```cpp
# include <iostream>
# include <vector>
using namespace std;
class Animal{public:    
             virtual void eat() const { cout << "I eat like a generic Animal." << endl; }    
             virtual ~Animal() {}}; 
class Wolf : public Animal{public:    
	void eat() const { cout << "I eat like a wolf!" << endl; }}; 
class Fish : public Animal{public:    
	void eat() const { cout << "I eat like a fish!" << endl; }}; 
class GoldFish : public Fish{public:    
	void eat() const { cout << "I eat like a goldfish!" << endl; }};  
class OtherAnimal : public Animal{};

int main(){    
    std::vector<Animal*> animals;    
    animals.push_back( new Animal() );    
    animals.push_back( new Wolf() );    
    animals.push_back( new Fish() );    
    animals.push_back( new GoldFish() );    
    animals.push_back( new OtherAnimal() );     
    for( std::vector<Animal*>::const_iterator it = animals.begin();       it != animals.end(); ++it)     
    {        (*it)->eat();        delete *it;    }    
    return 0;}
```







### 在程序中使用static

##### 1. 局部变量

普通局部变量是再熟悉不过的变量了，在任何一个函数内部定义的变量（不加static修饰符）都属于这个范畴。编译器一般不对普通局部变量进行初始化，也就是说它的值在初始时是不确定的，除非对其显式赋值。

> 普通局部变量存储于进程栈空间，使用完毕会立即释放。

静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。

> 变量在全局数据区分配内存空间；编译器自动对其初始化
> 其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束

静态局部变量的效果跟全局变量有一拼，但是位于函数体内部，就极有利于程序的模块化了。





### extern

如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。

当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的

当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!

 (1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.
 (2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.

static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它





