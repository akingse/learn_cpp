### 点乘

点积在数学中，又称数量积（dot product; scalar product），是指接受在实数R上的两个向量并返回一个实数值标量的二元运算。它是欧几里得空间的标准内积。

设二维空间内有两个向量 和 ， 和 表示向量a和b的大小，它们的夹角为 ，则内积定义为以下实数：
$$
\pmb a\cdot \pmb b=|a|\cdot |b|\, cos\theta
$$

该定义只对二维和三维空间有效。
这个运算可以简单地理解为：在点积运算中，第一个向量投影到第二个向量上（这里，向量的顺序是不重要的，点积运算是可交换的），然后通过除以它们的标量长度来“标准化”。这样，这个分数一定是小于等于1的，可以简单地转化成一个角度值。

### 叉乘

向量积，数学中又称外积、叉积，物理中称矢积、叉乘，是一种在向量空间中向量的二元运算。与点积不同，它的运算结果是一个向量而不是一个标量。并且两个向量的叉积与这两个向量和垂直。
$$
|\pmb a\times \pmb b|=|a|\cdot |b|\, sin\theta 
$$




| 名称                                          | 标积/内积/数量积/点积                                 | 矢积/外积/向量积/叉积                                        |
| --------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| 运算式（**a**，**b**和**c**粗体字，表示向量） | **a**·**b**=\|**a**\|\|**b**\|·cosθ                   | **a**×**b**=**c**，其中\|**c**\|=\|**a**\|\|**b**\|·sinθ，**c**的方向遵守右手定则 |
| 几何意义                                      | 向量**a**在向量**b**方向上的投影与向量**b**的模的乘积 | **c**是垂直a、b所在平面，且以\|**b**\|·sinθ为高、\|**a**\|为底的平行四边形的面积 |
| 运算结果的区别                                | 标量（常用于物理）/数量（常用于数学）                 | 矢量（常用于物理）/向量（常用于数学）                        |







### 精度控制

numeric_limits::epsilon [Wiki](https://en.wikipedia.org/wiki/Machine_epsilon)

```
#include <limits>

numeric_limits<float>::epsilon( ) 
numeric_limits<double>::epsilon( ) 


```

+-*/< 用时比例



CPU计算加减法的速度跟位运算（与、或、非、异或）相当，乘法的速度比加减法慢近10倍，除法的速度比加减法慢（近20倍——8位，近30倍——16位，40倍以上——32位）。算加减法，读取内存数据的比不读内存数据的慢，写内存的比读内存的慢。



**速度对比**

移位 > 赋值 > 大小比较 > 加法 > 减法 > 乘法 > 取模 > 除法。

实数运算速度：

| 运算符   | =     | +     | -     | *     | /       | %       |
| -------- | ----- | ----- | ----- | ----- | ------- | ------- |
| long int | 43.05 | 31.3  | 74.75 | 69.55 | 299.65  | 360.5   |
| int64    | 41.45 | 14.95 | 7.9   | 566.4 | 1243.45 | 1858.85 |
| double   | 46.15 | 10.25 | 12.6  | 33.65 | 1753.55 | –       |

总结：
▶除、模最慢
▶二维数组较慢
▶加减乘、逻辑位运算、比较大小较快
▶左右移位、一维数组、赋值几乎不需要时间。
▶循环for 或 while 语句十分特殊，它的运算速度大于判断大小、自加控制变量所用时间之和，无论采用内部 if 判断退出，还是在入口处判断，都会用去约 200ps 的时间。所以尽量减少循环次数，是优化算法的关键。对于双层或多层的循环，应把循环次数少的放在最外层，最大的循环位居最内部，以减少内层循环的执行次数。



### 位运算

 位运算是指按二进制进行的运算。在系统软件中，常常需要处理二进制位的问题。C语言提供了6个位操作运算符。这些运算符只能用于整型操作数，即只能用于带符号或无符号的char,short,int与long类型。

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。   | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。   | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。   | A >> 2 将得到 15，即为 0000 1111                             |



### register

寄存器、缓存、内存
为了加深对 register 变量的理解，这里有必要讲一下CPU寄存器。

按照与CPU的远近来分，离CPU最近的是寄存器，然后是缓存，最后是内存。

寄存器是最贴近CPU的，而且CPU只在寄存器中进行存取。寄存的意思是暂时存放数据，不用每次都从内存中取，它是一个临时的存放数据的空间。

而寄存器的数据又来源于内存，于是 CPU <-- 寄存器 <-- 内存，这就是它们之间的信息交换。


- 为寄存器变量分配寄存器是动态完成的，因此，只有局部变量和形式参数才能定义为寄存器变量。

- 
  局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。

- 
  寄存器的长度一般和机器的字长一致，所以，只有较短的类型如int、char、short等才适合定义为寄存器变量，诸如double等较大的类型，不推荐将其定义为寄存器类型。

- CPU的寄存器数目有限，因此，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的auto变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 register 关键字，也自动为其分配寄存器，无须由程序员来指定。



### 查看指针数组

二级指针

指针转换，变量监视，可以直接+1

```
(Tri*)0x0000027bb3e7b640+0
(Tri*)0x0000027bb3e7b640+1
```

