## 碰撞检测

应用：计算机游戏、计算机仿真模拟、机器人和计算物理学中；

游戏开发，3D建模，动画，虚拟现实和增强现实，物理仿真，路径规划，BIM设计施工阶段

分类：二维平面和三维碰撞，静态干涉和动态碰撞检测



#### 基本原理：

- mesh网格化（v）
- parameterization参数化（x）
- AABB包围盒预碰撞（v）
- 平面扫描，其他包围盒预处理（x）
- SAT分离轴，判断是否相交，计算相离的距离；（v）
- 数据结构：kd-tree，octree，BVH 层次包围盒（x）
- GJK和EPA计算凸多面体穿透深度（x）

测试navisworks，依据使用场景（分级），两个功能，整体移出和局部深度；

跟修工确认；



#### 核心功能实现：

硬碰撞判断（v）碰撞点信息（x）

软碰撞判断（v）最近点信息（v）

穿透深度计算（-）最近方向（x）





---

### 穿透深度

penetration depth (PD) 穿透深度，定义为使两个多面体的内部不相交的最小平移距离。侵入距离 IntrusionDistance；

#### 解决方案：

- Minkowski Sum 复杂度太大，凹多面体 n^6
- GJK和EPA，仅用于凸多面体
- chatgpt：无法直接使用 SAT。你可以先尝试将凹多面体分解为凸多面体的集合；
- 凹多面体凸分解 convex decomposition，也无法确定方向
- 输入方向，输出方向穿透距离；







### GJK算法

GJK算法是由 Gilbert,johnson和 Keerthi 3人在1988年共同开发的一类迭代算法。GJK算法的输入为两物体的顶点集，通过有限次数的迭代后，最后输出结果为两物体之间的欧氏距离。根据两物体之间 的欧氏距离，可进行碰撞检测。当两物体之间的距离等于或者小于零时，可判定两物体发生碰撞。

GJK是物理引擎中计算碰撞的主流方案；可以看成是MinkowskiDifference的超级优化；

两个凸多面体的碰撞，然后使用 GJK（Gilbert-Johnson-Keerthi）算法和 EPA（Expanding Polytope Algorithm）算法来计算穿透深度。

对于凹多面体，你无法直接使用 SAT。你可以先尝试将凹多面体分解为凸多面体的集合（例如，使用有序凸分解法，例如 HACD），然后使用 SAT 在这些凸多面体之间检测碰撞。在这种情况下，你需要计算每个凸多面体之间的穿透深度，并从中选择最大的穿透深度作为整个凹多面体之间的穿透深度。

Simplex单纯形，在MinkowskiDifference内需要寻找的最小图形，用于判断是否包含原点；

support函数，使用方向向量来查找Simplex；

```c
bool GJK(Shape shapeA, Shape shapeB)
{
	// 得到初始的方向
    Vector2 direction = findFirstDirection();
    // 得到首个support点
    simplex.add(support(direction));
    // 得到第二个方向
    direction = -direction;
    while(true)
    {
    	Vector2 p = support(direction);
        // 沿着dir的方向，已经找不到能够跨越原点的support点了。
        if (Vector2.Dot(p, direction) < 0)
            return false;	
        simplex.add(p);
        // 单形体包含原点了
        if (simplex.contains(Vector2(0, 0)))
            return true;
        direction = findNextDirection();
    }
}

```



用[QuickHull](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Quickhull)算法生成一个凸几何体,或者使用[V-HACD](https://link.zhihu.com/?target=https%3A//github.com/kmammou/v-hacd)等类似的算法将凹几何体分解成数个凸几何体



### EPA算法

Expanding Polytope Algorithm(EPA) 扩展多边形算法

```c
Vector2 EPA(Simplex simplex)
{
    // 构造一个首尾相连的多边形
    simplexEdge.initEdges(simplex);
    while(true)
    {
        // 找到距离原点最近的边
        Edge e = simplexEdge.findClosestEdge();
        // 沿着边的法线方向，尝试找一个新的support点
        Vector2 point = support(e.normal);
        // 无法找到能够跨越该边的support点了。也就是说，该边就是差集最近边
        float distance = Vector2.Dot(point, e.normal);
        if (distance - e.distance <= 0)
        {
            // 返回穿透向量
            return e.normal * distance;
        }
        // 将新的support点插入到多边形中。
        // 也就是将边e从support点位置分割成两条新的边，并替换到多边形集合中。
        simplexEdge.insertEdgePoint(e, point);
    }
}
```



### Minkowski

lMinkowski Sum and Minkowski Difference
$$
A + B = \{a + b|a∈A, b∈B\}
$$

闵可夫斯基和从几何上的直观理解是A集合沿B的边际连续运动一周扫过的区域与B集合本身的并集，也可以是B沿着A的边界连续运动扫过区域与A自身的并集。

GJK算法的核心就是闵可夫斯基差，即若两个多边形相交，则它们的闵可夫斯基差必然包括原点。两个相交的多边形，必然有一点既属于shape1，也属于shape2，相减则为原点（0，0）

如果两个凸多边形有重叠部分，则它们的Minkowski sums也会存在一个包含原点的重叠区域。因此，在计算Minkowski sums时，我们通常将其中一个凸多边形反转一下（即取相反数），这样它的形状就成为了原凸多边形包围盒（Axis-Aligned Bounding Box或AABB）。然后我们将该AABB和另一个凸多边形作为输入，求出它们的Minkowski sums，并判断是否包含原点。

如果结果包含原点，则说明两个凸多边形之间存在重叠部分，即发生了碰撞。否则它们不重叠，即没有碰撞。



设平面图的顶点数、边数 和区域数分别为 v，e 和 f，则由欧拉公式有 v-e+f=2。

四面体，4-6+4

六面体 8-12+6



基于体分解的包围体层次 ISBVH

论文：碰撞响应中方向穿透深度算法的研究



---

## 包围盒

### OBB包围盒

Oriented Bounding Box

用包围球做第一回合的快速测试，用OBB进行第二回合的测试。第一回合的测试可以剔除大多数不可见或不必裁剪的物体，这样不必进行第二回合测试的几率就会大得多。同时，OBB包围盒测试所得的结果更精确，最终要绘制的物体会更少。这种混合式的包围盒也适用于其他方面，如碰撞检测、物理/力学等

要计算两个OBB是否碰撞，只需要计算他们在图3上的4个坐标轴上的投影是否有重叠，如果有，则两多边形有接触。

判定方式：两个多边形在所有轴上的投影都发生重叠，则判定为碰撞；否则，没有发生碰撞。

OBB存在多种的表达方式，（二维）最常用的一种：一个中心点、2个矩形的边长、两个旋转轴（该轴垂直于多边形自身的边，用于投影计算）

### AABB包围盒

AABB包围盒(Axis-Aligned Bounding Box) 是一种简单的包围体,它使用两个点来表示一个轴对齐的矩形区域。
AABB包围盒具有以下特点:

1. 两个点分别表示包围盒的最小点(min)和最大点(max)。
2. 包围盒的边界与坐标轴的方向一致,边界线与坐标轴之间的夹角为90度。因此AABB包围盒也称作坐标轴对齐的包围盒。
3. AABB包围盒简单易构造,Checking是否包含某点的计算量小。所以非常适合用于快速碰撞检测等。
4. 能够很好地近似许多物体的外形,具有一定的适用性。
5. 当物体发生平移、缩放变换时,AABB包围盒也可以很简单地进行相应变换。
   AABB包围盒经常用于3D空间中的物体包围和碰撞检测。
   其中蓝色点表示包围盒的8个顶点,红色点表示包围盒的最小点min和最大点max。
   所以,简而言之,AABB包围盒是一种简单的包围盒,它使用两个轴对齐的点来表示包围区域,广泛用于3D物体包围和碰撞检测领域。

快速求交

两个AABB包围盒的集合，想要快速求出它们相交的部分，你可以考虑使用空间分割数据结构，例如kd-tree或octree。这些数据结构可以将空间划分成不同的块或箱子，以有效地提高搜索和查询速度。



### 平面扫面算法

平面扫面算法是一种广泛用于3D环境中的碰撞检测和物体间相交计算的算法。它的基本思想是:

1. 将3D空间划分为多个平面,每个平面上放置一组物体或物体的包围体(通常是AABB包围盒)。

2. 选择一个轴(通常是y轴或z轴),沿着该轴方向逐渐"扫过"每个平面。

3. 在扫过每个平面时,检测该平面上的物体或包围体之间是否有碰撞或相交。

4. 通过扫面顺序,我们只需要在相邻平面之间检测碰撞,这减少了整个3D空间的碰撞检测量。

5. 由于物体只在某个平面上移动,所以我们可以通过追踪物体在上一平面上的状态来预测并优化当前平面上的碰撞检测。
   这个算法的优点是:

6. 将3D碰撞检测问题转换为2D,降低了计算复杂度。

7. 采用增量式检测,避免重复检测,提高效率。

8. 可预测并优化相邻平面之间的碰撞检测。

9. 空间上的连续物体,在平面扫面过程中也是连续的,这有利于相交计算。
   它的基本实现过程是:

10. 定义平面和轴,初始化平面上的物体和包围体。

11. 选择第一个平面,检测平面上的碰撞和相交。

12. 移动到下一个平面,预测并优化与上一平面碰撞相关的检测。同时检测新产生的碰撞。

13. 重复步骤3,逐层扫过每个平面。

14. 所有平面扫过后结束,得到最终的碰撞和相交结果。

    

---

### PQP-TriDist

两个polyface求最小距离（三角面片求交）

[pqp](https://gamma.cs.unc.edu/SSV/)

邻近查询包 Proximity Query Package

   * collision detection - detect whether two models overlap, and optionally, which triangles of the models  overlap. 是否碰撞，具体到三角面片
     
   * distance computation - compute the distance between two models,  i. e., the length of the shortest translation  that makes the models overlap 距离计算，最近距离
     
   * tolerance verification - detect whether two models are closer or farther than a tolerance value. 公差验证，距离与公差值比较



paper

基于rssobb混合层次包围盒精确碰撞检测研究

计算三角形之间的精确距离以及确切的碰撞位置。与上文计算长方形之间距离相似，两个三角形之间的最近点,或者落在角形边上,或者在三角形内部。三角形边与边之间的距离运算同样用到Gilbert算法;三角形顶点与三角形面之间的距离则需要精确计算。

a fast procedure for computing the distance between complex object in 3d space

On fast computation of distance between line segments.

- 两个线段之间的最小距离；Gilbert
- 三角形顶点到三角形面之间的距离；

估计凸多面体间穿透深度的双空间展开——gamma团队

我们提出了一种增量算法来估计三维凸多面体之间的穿透深度。该算法通过在Minkowski和的表面上行走来逐步寻求“局部最优解”。Minkowski和的曲面是通过构造局部高斯映射来隐式计算的。在实践中，当环境中存在高运动相干时，该算法工作良好，并且在大多数情况下能够计算最优解。



### 算法的局限性

 Dual-space Expansion for Estimating Penetration depth between convex polytopes 估计凸多面体间穿透深度的双空间展开

Minkowski Sum 复杂度太大

当问题变得复杂时候，解决方案就会变得学术，论文很难啃，学术论文背后有很多专业的概念，比如闵可夫斯基和，还有一些作者自己定的概念，比如RSS(矩形扫掠球)，看懂论文，分析解决方案可行性，再到写实现，有很长的路要走；



---

## BV

往往包裹性越好的BV，相交测试越复杂，但是包裹性好可以减少相交测试的次数。

BVH建树困难也就意味着这个技术不适合运行时期动态更新。BVH和BSP一样往往是在非运行时期对静态物体进行预计算。

性能测试公式揭示了碰撞性能的消耗：
$$
T = NvCv + NpCp + NuCu + Co
$$
Nv是相交测试BV的数量，Cv是每次相交测试的消耗，Np是相交测试图元的数量，Cp是每次相交测试的消耗，Nu是需要更新节点的数量，Cu是更新节点的消耗，Co是一个常量消耗。

### BVH 层次包围盒(Bounding Volume Hierarchy)

BVH的核心思想就是用体积略大而几何特征简单的包围盒来近似描述复杂的几何对象，并且这种包围盒是嵌套的，我们只需要对包围盒进行进一步的相交测试，就可以越来越逼近实际对象（很明显这个功能需要用到树形的层次结构）。

![img](https://pic4.zhimg.com/80/v2-5bff610798835ab95d23a5a591e47ccb_1440w.webp)



---

### 空间搜索树

```
B树（B-tree）：
    特点：B树是一种多路搜索树，常用于关系型数据库中，具有平衡的树结构，适用于范围查询和排序操作。
    使用场景：适合于需要进行范围查询和排序的场景，如根据某个范围内的数值或日期进行检索。
    示例：订单表中的订单日期字段，如果需要按日期范围查询某段时间内的订单数据，可以使用B树索引。

哈希索引（Hash Index）：
    特点：哈希索引通过计算哈希值来快速定位数据，适用于等值查询。
    使用场景：适合于只需要进行等值匹配查询的场景，不适合范围查询。
    示例：用户表中的用户名字段，如果只需要根据用户名进行精确匹配查询用户信息，可以使用哈希索引。

全文索引（Full-text Index）：
    特点：全文索引用于对文本字段进行全文搜索，支持关键词搜索和匹配。
    使用场景：适合于需要对文本数据进行搜索的场景，如博客、新闻、论坛等应用。
    示例：新闻文章表中的正文内容字段，如果需要根据关键词进行全文搜索，可以使用全文索引来加速搜索操作。

R树（R-tree）：
    特点：R树主要用于多维数据的索引和查询，适用于空间数据的范围查询和最近邻查询。
    使用场景：适合于地理信息系统（GIS）、地图应用、物流路径规划等对空间数据进行查询和分析的场景。
    示例：地图应用中存储的地理位置数据，如城市边界、地标点等，可以使用R树来高效地支持空间范围查询和附近位置查询。

```

**Rtree**

[R树](https://blog.csdn.net/cyq6239075/article/details/126677345)是一种用于处理多维数据的数据结构，用来访问二维或者更高维区域对象组成的空间数据.R树是一棵平衡树。树上有两类结点：叶子结点和非叶子结点。每一个结点由若干个索引项构成。



**kd-tree搜索**

kd-tree（k-dimensional树的简称），是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。 [1] 主要应用于多维空间关键数据的搜索（如：范围搜索和最近邻搜索）。K-D树是二进制空间分割树的特殊的情况。

根据具体的应用场景和数据特点来选择合适的索引结构。如果需要进行范围查询或处理高维度数据，R树可能更适合；如果需要最近邻查询或处理低维度数据，kd树可能更适合。





### 体素化

三维像素化（pixel）体素(Voxel)

平面三角形的像素化采样方法，也可以看作是三角面片与平面包围盒的求交算法，基于三角面片的求交算法也可以完成3D图形的体素化。基于空间采样的方式划分3维体素数组，使用三角形与空间AABB包围盒的求交算法确定这些基本体元所能影响到的体素单元，将这些体素标记为非空，这样就完成了对3D模型表面的体素化操作。对于内部的体素化，计算三角形到体素化网格中心点的距离，设定阈值进行判断。



---

### 分离轴定理

- 分离轴定理算法十分得快

- 分离轴定理算法十分得准

- but

- 分离轴定理算法只适用于凸多边形，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。
- 分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。

#### 凸特性

  如前所述，SAT是一种确定两个凸多边形是否相交的方法。如果某个形状与任何穿过该形状的直线只交叉两次，则该形状被称为凸多边形。如果某个形状与穿过该形状的直线交叉两次以上，则该形状为非凸（或凹）。

SAT指出：“**如果两个凸面物体没有穿透，则存在一根轴，使得这两个物体在该轴上的投影不重叠。**”

二维凸包，获取分离轴，**只要测试每个多边形的边的法线即可**





