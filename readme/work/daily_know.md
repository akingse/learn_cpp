







### 精度控制

numeric_limits::epsilon [Wiki](https://en.wikipedia.org/wiki/Machine_epsilon)

```
#include <limits>

numeric_limits<float>::epsilon( ) 
numeric_limits<double>::epsilon( ) 


```

+-*/< 用时比例



CPU计算加减法的速度跟位运算（与、或、非、异或）相当，乘法的速度比加减法慢近10倍，除法的速度比加减法慢（近20倍——8位，近30倍——16位，40倍以上——32位）。算加减法，读取内存数据的比不读内存数据的慢，写内存的比读内存的慢。



**速度对比**

移位 > 赋值 > 大小比较 > 加法 > 减法 > 乘法 > 取模 > 除法。

实数运算速度：

| 运算符   | =     | +     | -     | *     | /       | %       |
| -------- | ----- | ----- | ----- | ----- | ------- | ------- |
| long int | 43.05 | 31.3  | 74.75 | 69.55 | 299.65  | 360.5   |
| int64    | 41.45 | 14.95 | 7.9   | 566.4 | 1243.45 | 1858.85 |
| double   | 46.15 | 10.25 | 12.6  | 33.65 | 1753.55 | –       |

总结：
▶除、模最慢
▶二维数组较慢
▶加减乘、逻辑位运算、比较大小较快
▶左右移位、一维数组、赋值几乎不需要时间。
▶循环for 或 while 语句十分特殊，它的运算速度大于判断大小、自加控制变量所用时间之和，无论采用内部 if 判断退出，还是在入口处判断，都会用去约 200ps 的时间。所以尽量减少循环次数，是优化算法的关键。对于双层或多层的循环，应把循环次数少的放在最外层，最大的循环位居最内部，以减少内层循环的执行次数。